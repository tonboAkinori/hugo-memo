[
  {
    "content": "Makefileの基本的な文法は下記になる\nターゲット：コンポーネント コマンド(コンポーネントからターゲット作成する方法を記述する) Makefileの文法確認 (1) [sub.h] #ifndef __INCLUDE_SUB_H_  #define __INCLUDE_SUB_H_  void Greeting(char* str); #endif // __INCLUDE_SUB_H_ [sub.c] #include \u003cstdio.h\u003e #include \"sub.h\" void Greeting(char* str) { printf(\"\u003e %s\\n\", str); } [main.c] #include \"sub.h\" void main(void) { Greeting(\"Hello world!\"); } [Makefile] TARGET = app #CC = OBJS = main.o sub.o ${TARGET}: ${OBJS} ${CC} -o ${TARGET} ${OBJS} main.o: main.c ${CC} -c main.c sub.o: sub.c ${CC} -c sub.c clean: ${RM} *~ *.o ${TARGET} ■実行結果 $make cc -c main.c cc -c sub.c cc -o app main.o sub.o Makefileの文法確認(2) (1)の記述では、ヘッダファイルの sub.h が更新されてもターゲットは更新されない。 Makefile に記載されている依存関係が .c ファイルだけのため。\n$make cc -c main.c cc -c sub.c cc -o app main.o sub.o $ touch sub.h $ make make: 'app' は更新済みです. $ emacs Makefile \u003c- 下記にMakefileを書き直し $ make cc -c sub.c cc -o app main.o sub.o [Makefile] TARGET = app #CC = OBJS = main.o sub.o ${TARGET}: ${OBJS} ${CC} -o ${TARGET} ${OBJS} main.o: main.c ${CC} -c main.c sub.o: sub.c ${CC} -c sub.c sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ",
    "description": "",
    "tags": null,
    "title": "基本文法",
    "uri": "/makefile/001-makefile/"
  },
  {
    "content": "空白やタブで区切られたテキストを処理するコマンド。 演算機能もあり、プログラミング言語としても使用される。\nawk ' BEGIN{ 最初に実行されるブロック } { メインブロック } END{ 最後に実行されるブロック } ' 処理するファイルの内容は下記とする。\nA 1 A B 2 C D 3 D E 1 E $ awk 'BEGIN{print \"=== Start ===\"}{print $0}END{print \"=== End ===\"}' test.txt === Start === A 1 A B 2 C D 3 D E 1 E === End === ",
    "description": "",
    "tags": null,
    "title": "基本構文",
    "uri": "/command/awk/001-awk/"
  },
  {
    "content": "ディレクトリやファイルの再帰的な検索を行う\nfind \u003c検索位置\u003e \u003cexpression\u003e 検索を試したディレクトリ構造\n. ├── 001 │ ├── 001-01 │ │ └── 001-01.txt │ └── 001-02 ├── 002 └── 003 └── 003.txt ",
    "description": "",
    "tags": null,
    "title": "基本構文",
    "uri": "/command/find/001-find/"
  },
  {
    "content": "grep PATTERN [FILE...] パターンにマッチする行を表示する。\nファイルが指定されない場合や、ファイル名の代わりに - が指定されている場合は標準入力から検索する\n",
    "description": "",
    "tags": null,
    "title": "基本構文",
    "uri": "/command/grep/001-grep/"
  },
  {
    "content": "コマンド1 | コマンド2 | ... あるコマンドが 標準出力 に出力した内容を、他のコマンドの 標準入力 にする。\n",
    "description": "",
    "tags": null,
    "title": "基本構文",
    "uri": "/command/pipe/001-pipe/"
  },
  {
    "content": "xargs [command [initial-arguments]] 標準入力を読み込みコマンドラインを作成し、それを実行する。\nこのコマンドは、標準入力から空白や改行で区切られた一連の項目を読み込み(空白はダブルクォートなどで保護できる)、\nそれを引数で指定した command を1回以上実行する。\ncommand に対して指定した引数があれば、標準入力から読み込んだ項目はその後ろに追加される。\n次に、xargs を用いる場合、用いない場合での動作の違いを確認した。\ncat コマンドの概要 cat [File...] 指定したFILEの内容を標準出力へ出力する。 FILEが一つも与えられないと標準入力から読み込む。\ncat コマンドを用いた動作確認 aaa.txt に以下の内容を記載して確認した。\nhoge xargs を用いない場合 aaa.txt が標準入力として与えられる。\n$ echo aaa.txt | cat aaa.txt xargs を用いる場合 aaa.txt がFILEとして与えられる。\n$ echo aaa.txt | xargs cat hoge grep コマンドを用いた動作確認 aaa.txt に以下の内容を記載して確認した。\nhoge xargs を用いない場合 aaa.txt が標準入力として与えられる。\nこのため、ファイルの内容ではなく文字列 aaa.txt とマッチする。\n$ echo aaa.txt | grep aaa aaa.txt xargs を用いる場合 aaa.txt が FILE として与えられる。\nこのため、ファイルの内容とマッチする。\n$ echo aaa.txt | xargs grep hoge hoge ",
    "description": "",
    "tags": null,
    "title": "基本構文",
    "uri": "/command/xargs/001-xargs/"
  },
  {
    "content": "通常のコンパイラは、ファイル単位でコンパイルし「オブジェクトファイル」と呼ばれるファイルを作成する。\n最終的にオブジェクトファイルが結合されるときに、実際の関数呼び出しに置き換えられる。\nこの結合作業を「リンク」と呼ぶ。\nスタートアップルーチン 標準ライブラリの関数が利用されていない場合でも、 実行できる形式にするために スタートアップルーチン と呼ばれる初期化を行うプログラムがリンクされる。\nスタートアップルーチンでは、レジスタの初期化や main 関数への引数設定や各種初期化が行われる。\nプログラムで最初に実行されるのは、main 関数ではなくスタートアップルーチンである。\n",
    "description": "",
    "tags": null,
    "title": "リンクまでの流れ",
    "uri": "/linker/link/"
  },
  {
    "content": "gcc は指定されたファイルを読み込み、ファイルの形式に応じて下記の作業を順番に行う。\n本当の意味でのコンパイラは cc1 であり、このため gcc は 「コンパイラドライバー」 とも呼ばれる。\n プリプロセス (ccp1) コンパイル (ccp1) アセンブル (as) リンク (collect2)  gccで-v オプションを指定するとgccが行う処理の詳細が出力される。\n$ gcc -v main.c Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper OFFLOAD_TARGET_NAMES=nvptx-none:hsa OFFLOAD_TARGET_DEFAULT=1 Target: x86_64-linux-gnu Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.3.0-17ubuntu1~20.04' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu Thread model: posix gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' /usr/lib/gcc/x86_64-linux-gnu/9/cc1 ★ ccp1 コマンド★ -quiet -v -imultiarch x86_64-linux-gnu main.c -quiet -dumpbase main.c -mtune=generic -march=x86-64 -auxbase main -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccfwreyC.s GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu) compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 ignoring nonexistent directory \"/usr/local/include/x86_64-linux-gnu\" ignoring nonexistent directory \"/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed\" ignoring nonexistent directory \"/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/include\" #include \"...\" search starts here: #include \u003c...\u003e search starts here: /usr/lib/gcc/x86_64-linux-gnu/9/include /usr/local/include /usr/include/x86_64-linux-gnu /usr/include End of search list. GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu) compiled by GNU C version 9.3.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072 Compiler executable checksum: bbf13931d8de1abe14040c9909cb6969 COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' as ★ as コマンド ★ -v --64 -o /tmp/cc0U4iJC.o /tmp/ccfwreyC.s GNU assembler version 2.34 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.34 COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/ LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../:/lib/:/usr/lib/ COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' /usr/lib/gcc/x86_64-linux-gnu/9/collect2 ★ collect2 コマンド ★ -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper -plugin-opt=-fresolution=/tmp/ccYW7lFB.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/cc0U4iJC.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/9/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64' ",
    "description": "",
    "tags": null,
    "title": "GCCでリンクまでの処理確認",
    "uri": "/linker/link_gcc/"
  },
  {
    "content": "-f でプログラムファイルを指定する。\nBEGIN{ print \"START\" } { print \"---\" print $0 } END{ print \"END\" } $ awk -f プログラムファイル test.txt START --- A 1 A --- B 2 C --- D 3 D --- E 1 E END ",
    "description": "",
    "tags": null,
    "title": "プログラムファイル読み込み",
    "uri": "/command/awk/002-awk/"
  },
  {
    "content": "make も予め定義されたマクロがあり使うことが出来る。 下記のコマンドでマクロを確認できる\n$ make -p  Note ただし、 Makefile のある場所で実施すると Makefile の定義が反映されるので注意  マクロの優先順位 参照できるマクロが複数あるため優先順位は意識すること。 優先順位が高い順に並べる。\n コマンドラインで定義されたもの Makefile 内で定義されたもの　 環境変数 makeで予め定義されているもの  マクロ文字列の置換 マクロ文字列を使うと簡単にファイル名などを変更することが可能。 下記では、${SRCS:.c=.o} で SRCS の .c を .o に変更している\n[Makefile] TARGET = app SRCS = main.c sub.c OBJS = ${SRCS:.c=.o} ${TARGET}: ${OBJS} ${CC} -o ${TARGET} ${OBJS} main.o: main.c ${CC} -c main.c sub.o: sub.c ${CC} -c sub.c sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ",
    "description": "",
    "tags": null,
    "title": "マクロ",
    "uri": "/makefile/002-makefile-macro/"
  },
  {
    "content": "$ find . . ./001 ./001/001-01 ./001/001-01/001-01.txt ./001/001-02 ./002 ./003 ./003/003.txt ",
    "description": "",
    "tags": null,
    "title": "検索位置のみを指定",
    "uri": "/command/find/002-find/"
  },
  {
    "content": "タイプで指定できる一覧。\n   タイプ 内容     b ブロック(バッファー)特別   c 文字(バッファーなし)特別   d ディレクトリ   p 名前付きパイプ   f 標準ファイル   l シンボリックリンク   s ソケット    1 2 3 4 5 6 7  $ find . -type d . ./001 ./001/001-01 ./001/001-02 ./002 ./003   1 2 3  $ find . -type f ./001/001-01/001-01.txt ./003/003.txt   ",
    "description": "",
    "tags": null,
    "title": "ファイルタイプを指定",
    "uri": "/command/find/003-find/"
  },
  {
    "content": "if-elseやandなども使える。\n$ awk '{if($2==1) print $0}' test.txt A 1 A E 1 E ",
    "description": "",
    "tags": null,
    "title": "制御構文",
    "uri": "/command/awk/003-awk/"
  },
  {
    "content": "   自動変数 内容 有効範囲     $@ 処理中ターゲット コマンド行で有効   $% ターゲットがアーカイブメンバのときのターゲットメンバ名    $\u003c 最初に記載した依存ファイルの名前 (ヘッダをソースより後ろに配置することでヘッダの更新に使える)    $^ 依存しているすべてのファイル    $? ターゲットよりタイムスタンプが新しい依存ファイル    $$@ 処理中のターゲット コンポーネントのみで使える    [Makefile] TARGET = app SRCS = main.c sub.c OBJS = ${SRCS:.c=.o} ${TARGET}: ${OBJS} ${CC} -o $@ ${OBJS} main.o: main.c ${CC} -c $? sub.o: sub.c ${CC} -c $? sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ■実行結果 $make cc -c main.c cc -c sub.c sub.h cc -o app main.o sub.o $ls Makefile app main.c main.o sub.c sub.h sub.h.gch sub.o \u003e\u003e sub.g.gch というファイルが出来てしまった。 ■確認 $make -p | less で, sub.h を検索すると、下記のルールが作成されていた。 Makefileで sub.o をターゲットとするルールは分かれているが、統合されていた。 $?はターゲットより新しい依存ファイルのため sub.g.gch というファイルが作られてしまった。 ■作成されていたルール sub.o: sub.c sub.h ${CC} -c $? .gchファイル ヘッダファイルもコンパイルができるらしい。 コンパイル済みヘッダとなり、.gchとして出力される。 このファイルを利用することで、ヘッダファイルの処理を省略できる。 ただし、コンパイル済みヘッダは１回のコンパイルで1つしか使えないらしい。 そのため、ヘッダーファイルに必要なヘッダをすべて記述するとかするらしい。\n",
    "description": "",
    "tags": null,
    "title": "自動変数",
    "uri": "/makefile/003-makefile-auto-variable/"
  },
  {
    "content": "print でレコードを出力する場合は、カンマが OFS で指定した区切り文字に入れ替えられる。\nカンマで区切り OFSでフィールドが区切られる。\nBEGIN{ FS = \"%\" OFS =\"#\" } { print $1,$2,$3 } 次の実行結果では、%から#の区切りに変更される。\n$ echo 1%2:3%A%4 | awk -f sample.awk 1#2:3#A スペースで区切る場合(カンマで区切らない場合) OFSでフィールドが区切られない。\nBEGIN{ FS = \"%\" OFS =\"#\" } { print $1 $2 $3 } 次の実行結果では、OFSでフィールドが区切られていない。\n$ echo 1%2:3%A%4 | awk -f sample.awk 12:3A ",
    "description": "",
    "tags": null,
    "title": "print 出力時のフィールド区切り",
    "uri": "/command/awk/004-awk/"
  },
  {
    "content": "1 2  $ find . -type f -name 003* ./003/003.txt   ",
    "description": "",
    "tags": null,
    "title": "ファイル名を指定",
    "uri": "/command/find/004-find/"
  },
  {
    "content": "複数ターゲットを指定するとどうなるか確認してみた。\n下記の場合は、最初のターゲット(app)のみがビルドされた。\nTARGET = app hoge SRCS = main.c sub.c OBJS = ${SRCS:.c=.o} ${TARGET}: ${OBJS} ${CC} -o $@ ${OBJS} main.o: main.c ${CC} -c main.c sub.o: sub.c ${CC} -c sub.c sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ■実行結果 $ make cc -c main.c cc -c sub.c cc -o app main.o sub.o $ make hoge cc -o hoge main.o sub.o all ターゲットを作成することで、どちらもビルドされた。\n[Makefile] TARGET = app hoge SRCS = main.c sub.c OBJS = ${SRCS:.c=.o} all: app hoge ${TARGET}: ${OBJS} ${CC} -o $@ ${OBJS} main.o: main.c ${CC} -c main.c sub.o: sub.c ${CC} -c sub.c sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ■実行結果 $ make cc -c main.c cc -c sub.c cc -o app main.o sub.o cc -o hoge main.o sub.o ",
    "description": "",
    "tags": null,
    "title": "複数ターゲット",
    "uri": "/makefile/004-makefile-multi-target/"
  },
  {
    "content": "Home ",
    "description": "",
    "tags": null,
    "title": "Home",
    "uri": "/"
  },
  {
    "content": "リンカー リンクまでの流れ GCCでリンクまでの処理確認  ",
    "description": "",
    "tags": null,
    "title": "リンカー",
    "uri": "/linker/"
  },
  {
    "content": " 基本構文 プログラムファイル読み込み 制御構文 print 出力時のフィールド区切り 組み込み変数  ",
    "description": "",
    "tags": null,
    "title": "awk",
    "uri": "/command/awk/"
  },
  {
    "content": "Command awk find grep xargs | (パイプ)  ",
    "description": "",
    "tags": null,
    "title": "Command",
    "uri": "/command/"
  },
  {
    "content": " 基本構文 検索位置のみを指定 ファイルタイプを指定 ファイル名を指定  ",
    "description": "",
    "tags": null,
    "title": "find",
    "uri": "/command/find/"
  },
  {
    "content": " 基本構文  ",
    "description": "",
    "tags": null,
    "title": "grep",
    "uri": "/command/grep/"
  },
  {
    "content": " 基本構文  ",
    "description": "",
    "tags": null,
    "title": "xargs",
    "uri": "/command/xargs/"
  },
  {
    "content": " 基本構文  ",
    "description": "",
    "tags": null,
    "title": "| (パイプ)",
    "uri": "/command/pipe/"
  },
  {
    "content": "オプションから変数を指定することもできる。\nmake -p makefile を読み込んで得られたデータベース　(規則と変数の値) を出力する。\nmake -n 実行するコマンドの表示だけを行う。\n変数に値を設定する $ make CFLAGS=-g cc -g -c -o main.o main.c cc -g -c -o sub.o sub.c cc -g -o app main.o sub.o $ make \"CFLAGS=-g -DDEBUG\" cc -g -DDEBUG -c -o main.o main.c cc -g -DDEBUG -c -o sub.o sub.c cc -g -DDEBUG -o app main.o sub.o 複数のオプションを設定する場合 $ make CFLAGS=-g LIB=-l cc -g -c -o main.o main.c cc -g -c -o sub.o sub.c cc -g -l -o app main.o sub.o [Makefile] TARGET = app SRCS = main.c sub.c OBJS = ${SRCS:.c=.o} # MAKEFLAGS += --no-builtin-rules # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # %.o: %.c # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} $\u003c ${TARGET}: ${OBJS} ${LINK.c} ${OUTPUT_OPTION} ${OBJS} ${LIB} sub.o: sub.h clean: ${RM} *~ *.o ${TARGET} ",
    "description": "",
    "tags": null,
    "title": "コマンドオプション",
    "uri": "/makefile/005-makefile-option/"
  },
  {
    "content": "   変数名 内容     FNR 現在処理しているファイルの入力レコード番号、処理するファイルが１つの場合は NR と同じ   FS 入力フィールドのセパレーター、デフォルトはスペース   NF 現在入力レコードのフィールド数   NR 現在処理している行番号   OFS 出力フィールドのセパレーター、デフォルトはスペース   ORS 出力レコードのセパレーター、デフォルトはスペース   RS 入力レコードのセパレーター、デフォルトは改行    FS BEGIN{ FS =\",\" } { print $2 } $ echo 1,2:3,4 | awk -f sample.awk 2:3 NF BEGIN{ FS=\",\" } { if(NF \u003c 3) { print NR\"#\",\"列が不足しています\" } else { print NR\"#\",$0 } } $ echo -e \"1,2:3*A,4\\na,b\\n7,8,9,10\" | awk -f sample.awk 1# 1,2:3*A,4 2# 列が不足しています 3# 7,8,9,10 NR BEGIN{ } { print NR\"#\", $0 } $ echo -e \"1,2:3*A,4\\na,b,c\" | awk -f sample.awk 1# 1,2:3*A,4 2# a,b,c OFS print 出力をスペースで区切ると、区切り文字として出力されない。\nBEGIN{ FS = \",\" OFS =\"%\" } { print $1 $2 $3 } $ echo 1,2:3*A,4 | awk -f sample.awk 12:3*A4 print 出力をカンマで区切ると、区切り文字が出力される。\nBEGIN{ FS = \",\" OFS =\"%\" } { print $1,$2,$3 } echo 1,2:3*A,4 | awk -f sample.awk 1%2:3*A%4 ",
    "description": "",
    "tags": null,
    "title": "組み込み変数",
    "uri": "/command/awk/005-awk/"
  },
  {
    "content": "ヘッダファイルの依存に対応する ヘッダファイルの更新でビルドされる Makefile を作成する。\n[sub_a.h] #ifndef __INCLUDE__SUB_A  #define __INCLUDE__SUB_A  void sub_a(void); void sub_A(void); #endif // __INCLUDE__SUB_A [sub_b.h] #ifndef __INCLUDE__SUB_B  #define __INCLUDE__SUB_B  void sub_b(void); #endif // __INCLUDE__SUB_B [sub_ab.c] #include \u003cstdio.h\u003e #include \"sub_a.h\" #include \"sub_b.h\" void sub_a(void) { printf(\"\u003e Call sub_a\\n\"); } void sub_b(void) { printf(\"\u003e Call sub_b\\n\"); } [parse.h] #ifndef __INCLUDE__PARSE_H  #define __INCLUDE__PARSE_H  void parse(void); #endif // __INCLUDE__PARSE_H [parse.c] #include \u003cstdio.h\u003e #include \"parse.h\" void parse(void) { printf(\"\u003e Call parse\\n\"); } [main.c] #include \"sub_a.h\" #include \"sub_b.h\" #include \"parse.h\" void main(void) { sub_a(); sub_b(); parse(); } ヘッダファイルの依存関係を考慮しない Makefile を作成すると以下のようになる。\n[Makefile] #ヘッダファイルの依存関係に対応する TARGET = app SRCS = main.c sub_ab.c parse.c OBJS = ${SRCS:.c=.o} # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # %.o: %.c # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} $\u003c ${TARGET}: ${OBJS} ${LINK.c} ${OUTPUT_OPTION} ${OBJS} clean: ${RM} *~ *.o ${TARGET} ビルド結果は下記になる\n$ make cc -c -o main.o main.c cc -c -o sub_ab.o sub_ab.c cc -c -o parse.o parse.c cc -o app main.o sub_ab.o parse.o ここで、 parse.h を更新して再ビルドしてみる。\n$ touch parse.h $ make make: 'app' は更新済みです. parse.o と parse.h の依存が書かれていないため make は更新が必要ない判断しているためである。\nファイル数が少なければひとつずつ対応できるが、さらに簡単に対応できる方法がある。\nコンパイラにはソースコードに必要なヘッダファイルがわかっているため、 コンパイラによっては依存するヘッダファイルの情報を出力してくれるものもある。\n-M オプション 標準ファイルも含めて依存関係がわかる。\n$ gcc -M sub_ab.c sub_ab.o: sub_ab.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \\ /usr/include/features.h /usr/include/x86_64-linux-gnu/sys/cdefs.h \\ /usr/include/x86_64-linux-gnu/bits/wordsize.h \\ /usr/include/x86_64-linux-gnu/bits/long-double.h \\ /usr/include/x86_64-linux-gnu/gnu/stubs.h \\ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \\ /usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h \\ /usr/include/x86_64-linux-gnu/bits/types.h \\ /usr/include/x86_64-linux-gnu/bits/typesizes.h \\ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \\ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \\ /usr/include/x86_64-linux-gnu/bits/libio.h \\ /usr/include/x86_64-linux-gnu/bits/_G_config.h \\ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \\ /usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h \\ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \\ /usr/include/x86_64-linux-gnu/bits/sys_errlist.h sub_a.h sub_b.h -MM オプション システムヘッダディレクトリにあるヘッダは対象外にして出力\n$ gcc -MM sub_ab.c sub_ab.o: sub_ab.c sub_a.h sub_b.h -MF file名 オプション -MMは標準出力だったが、指定したファイル名に依存関係を出力する\n$ gcc -MM sub_ab.c -MF sub.d $ cat sub.d sub_ab.o: sub_ab.c sub_a.h sub_b.h -MG オプション -MMは対象のヘッダが見つからない場合にエラーとなるが、 このオプションを使うとエラーとしない。 ヘッダファイルが自動生成される場合に使われる。\n-MP オプション 依存するヘッダファイルを偽のターゲットとして追加する\n-MD オプション -M は依存するヘッダファイルを調べるのみだが、 このオプションを使うとコンパイルも行われる。 なお、このオプションを使うと依存関係の結果が .d に出力される。\n-MMD オプション -MM は依存するヘッダファイルを調べるのみだが、 このオプションを使うとコンパイルも行われる。 なお、このオプションを使うと依存関係の結果が .d に出力される。\nヘッダファイル更新を考慮した Makefile これらを組み合わせて Makefile を書き直す。\n[Makefile] #ヘッダファイルの依存関係に対応する TARGET = app SRCS = main.c sub_ab.c parse.c OBJS = ${SRCS:.c=.o} DEPS = ${SRCS:.c=.d} # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # # %.o: %.c  # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c all: ${TARGET} # - を付けないと、.d がない場合にエラーとなる -include ${DEPS} # .d ファイルをインクルード %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} -MMD $\u003c ${TARGET}: ${OBJS} ${LINK.c} ${OUTPUT_OPTION} ${OBJS} clean: ${RM} *~ *.o ${TARGET} ${DEPS} 初回のビルドの場合、.dファイルが作成されておらず依存関係が不明でも問題ない。\n2回目以降のビルドの場合には、-MMD オプションにより依存関係が記載された .d ファイルが作成されている。\nこれを include で読み込むことでターゲットとコンポーネントの関係が読みこれる。\n■Make 前のファイル $ ls Makefile main.c parse.c parse.h sub_a.h sub_ab.c sub_b.h ■実行結果 $ make cc -c -o main.o -MMD main.c cc -c -o sub_ab.o -MMD sub_ab.c cc -c -o parse.o -MMD parse.c cc -o app main.o sub_ab.o parse.o $ ls Makefile main.c main.o parse.d parse.o sub_ab.c sub_ab.o app main.d parse.c parse.h sub_a.h sub_ab.d sub_b.h $ touch sub_a.h $ make cc -c -o main.o -MMD main.c cc -c -o sub_ab.o -MMD sub_ab.c cc -o app main.o sub_ab.o parse.o ■確認 $ ls Makefile main.c parse.c parse.h sub_a.h sub_ab.c sub_b.h $ make -p -n parse.o: parse.c \u003c== .h の依存関係はない。 # Implicit rule search has been done. # Implicit/static pattern stem: 'parse' # Last modified 2514-05-30 10:53:03.107374182 # File has been updated. # Successfully updated. # automatic # @ := parse.o # automatic # % := # automatic # * := parse # automatic # + := parse.c # automatic # | := # automatic # \u003c := parse.c # automatic # ^ := parse.c # automatic # ? := parse.c # variable set hash-table stats: # Load=8/32=25%, Rehash=0, Collisions=2/19=11% # recipe to execute (from 'Makefile', line 18): ${COMPILE.c} ${OUTPUT_OPTION} -MMD $\u003c $ make cc -c -o main.o -MMD main.c cc -c -o sub_ab.o -MMD sub_ab.c cc -c -o parse.o -MMD parse.c cc -o app main.o sub_ab.o parse.o $ ls Makefile main.c main.o parse.d parse.o sub_ab.c sub_ab.o app main.d parse.c parse.h sub_a.h sub_ab.d sub_b.h $ cat parse.d parse.o: parse.c parse.h $ make -p -n parse.o: parse.c parse.c parse.h \u003c==.h の依存関係が追加されている。 # Implicit rule search has been done. # Implicit/static pattern stem: 'parse' # Last modified 2021-02-11 00:54:28.0608391 # File has been updated. # Successfully updated. # recipe to execute (from 'Makefile', line 18): ${COMPILE.c} ${OUTPUT_OPTION} -MMD $\u003c .d ファイルが読み込まれて、.h の依存関係が追加されることが確認できた。\n",
    "description": "",
    "tags": null,
    "title": "ヘッダファイル",
    "uri": "/makefile/006-makefile-header/"
  },
  {
    "content": "とりあえずベタ書き。 シェルコマンドを使えばより簡単に書ける。\n. ├── Makefile ├── include │ ├── codec │ │ └── codec.h │ └── ui │ └── ui.h ├── lib │ ├── codec │ │ ├── Makefile │ │ └── codec.c │ └── ui │ ├── Makefile │ └── ui.c └── main.c [Makefile] TARGET := app SUB_TARGET := ui codec LIB_UI_DIR := lib/ui #lib/uiのソースコードを探索 LIB_UI_SRC := $(shell find ${LIB_UI_DIR} -type f -name \\*.c) LIB_UI_OBJS := ${LIB_UI_SRC:.c=.o} LIB_CODEC_DIR = lib/codec #lib/codecのソースコード探索 LIB_CODEC_SRC := $(shell find ${LIB_CODEC_DIR} -type f -name \\*.c) LIB_CODEC_OBJS := ${LIB_CODEC_SRC:.c=.o} INCLUDE_PATH = -Iinclude SRCS = main.c OBJS = ${SRCS:.c=.o} DEPS = ${SRCS:.c=.d} # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # # %.o: %.c # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c  all: ${SUB_TARGET} ${TARGET} ${SUB_TARGET}: ${MAKE} -C lib/$@ ${TARGET}: ${OBJS} ${LIB_UI_OBJS} ${LIB_CODEC_OBJS} ${LINK.c} ${OUTPUT_OPTION} ${OBJS} ${LIB_UI_OBJS} ${LIB_CODEC_OBJS} %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} ${INCLUDE_PATH} -MMD $\u003c clean: ${RM} *~ *.o ${TARGET} ${DEPS} ${MAKE} -C ${LIB_UI_DIR} clean ${MAKE} -C ${LIB_CODEC_DIR} clean  Note ターゲットの順番大事。TARGET を先にしていたことで SUB_TARGET が先に実施されずに意図しない処理になった。  [lib/codec/Makefile] #多段Makefile TARGET = codec.o INCLUDE_PATH = -I../../include SRCS = codec.c #OBJS = ${SRCS:.c=.o} DEPS = ${SRCS:.c=.d} # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # # %.o: %.c # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c  all: ${TARGET} -include ${DEPS} ${TARGET}: %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} ${INCLUDE_PATH} -MMD $\u003c clean: ${RM} *~ *.o ${TARGET} ${DEPS} [lib/ui/Makefile] #多段Makefile TARGET = ui.o INCLUDE_PATH = -I../../include SRCS = ui.c DEPS = ${SRCS:.c=.d} # COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c # LINK.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH) # OUTPUT_OPTION = -o $@ # # %.o: %.c # $(COMPILE.C) $(OUTPUT_OPTION) $\u003c  all: ${TARGET} -include ${DEPS} %.o: %.c ${COMPILE.c} ${OUTPUT_OPTION} ${INCLUDE_PATH} -MMD $\u003c clean: ${RM} *~ *.o ${TARGET} ${DEPS} ",
    "description": "",
    "tags": null,
    "title": "多段 Make",
    "uri": "/makefile/007-makefile-multi-make/"
  },
  {
    "content": "makeで使うことのできる演算子を記載する。\n   演算子 内容     = 変数が使われる度に評価される。シェルコマンドを代入している場合、変数を使う度に評価される。   := 一度だけ評価するため、定数として使える。   ?= 変数が定義されていないときのみ := として機能する   += 加算代入演算子。    ",
    "description": "",
    "tags": null,
    "title": "代入演算子",
    "uri": "/makefile/008-makefile-assign-operate/"
  },
  {
    "content": "   自動変数 内容     CFLAGS Cコンパイラに与える追加のフラグ   CXXFLAGS C++コンパイラに与える追加のフラグ   CPPFLAGS Cプリプロセッサに与える追加フラグ、プログラムに使われる。   LDFLAGS -Lのようなリンカーを実行をサポートする時にコンパイラに与えられる追加フラグ。代わりにライブラリ(-lfoo)は LDLIBS 変数に追加するべき。   LDLIBS ライブラリフラグや名前をコンパイラに与える、リンカーが実行される時にサポートする。 -Lのようなライブラリではないリンカーフラグは LDFLAGS 変数に与える。    ",
    "description": "",
    "tags": null,
    "title": "変数",
    "uri": "/makefile/009-makefile-variables/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Makefile",
    "uri": "/makefile/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
